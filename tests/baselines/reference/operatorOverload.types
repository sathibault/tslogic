=== tests/cases/compiler/operatorOverload.ts ===
var N=3;
>N : number
>3 : 3

N.toLocaleString();
>N.toLocaleString() : string
>N.toLocaleString : { (locales?: string | string[], options?: Intl.NumberFormatOptions): string; (locales?: Intl.LocalesArgument, options?: Intl.NumberFormatOptions): string; }
>N : number
>toLocaleString : { (locales?: string | string[], options?: Intl.NumberFormatOptions): string; (locales?: Intl.LocalesArgument, options?: Intl.NumberFormatOptions): string; }

var a: UInt<8>;
>a : UInt<8>

a = 1;
>a = 1 : UInt<8>
>a : UInt<8>
>1 : 1

a += 2;
>a += 2 : UInt<8>
>a : UInt<8>
>2 : 2

var b: uint16 = 300;
>b : uint16
>300 : 300

const x: UInt<1> = { width: 1, value: 1};
>x : UInt<1>
>{ width: 1, value: 1} : { width: number; value: number; }
>width : number
>1 : 1
>value : number
>1 : 1

const y: UInt<2> = x + x;
>y : UInt<2>
>x + x : UInt<1>
>x : UInt<1>
>x : UInt<1>

const z: UInt<2> = x + 1;
>z : UInt<2>
>x + 1 : UInt<1>
>x : UInt<1>
>1 : 1


const FX_SHR: uint8 = 15;
>FX_SHR : uint8
>15 : 15

function fx_mul(x: int32, y: int32) {
>fx_mul : (x: int32, y: int32) => Int<32>
>x : int32
>y : int32

  var prod: int64 = int64(x)*int64(y);
>prod : int64
>int64(x)*int64(y) : Int<64>
>int64(x) : Int<64>
>int64 : (x: Bits) => Int<64>
>x : int32
>int64(y) : Int<64>
>int64 : (x: Bits) => Int<64>
>y : int32

  return int32(prod >> FX_SHR);
>int32(prod >> FX_SHR) : Int<32>
>int32 : (x: Bits) => Int<32>
>prod >> FX_SHR : Int<64>
>prod : int64
>FX_SHR : uint8
}

