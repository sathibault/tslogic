=== tests/cases/compiler/tslxRtl.ts ===
type RtlScalar = Bits | boolean;
>RtlScalar : boolean | Bits

interface RtlExpr<T extends RtlScalar> extends RtlBits {
  val?: T;
>val : T

  build(): void;
>build : () => void
}

class Signal<T extends RtlScalar> implements RtlExpr<T> {
>Signal : Signal<T>

  _rtl: true;
>_rtl : true
>true : true

  build() {
>build : () => void
  }
}

class Driver<T extends RtlScalar> {
>Driver : Driver<T>

  is<U extends RtlScalar>(val: RtlExpr<T>, cond?: (x:any) => RtlExpr<U>) {
>is : <U extends RtlScalar>(val: RtlExpr<T>, cond?: (x: any) => RtlExpr<U>) => void
>val : RtlExpr<T>
>cond : (x: any) => RtlExpr<U>
>x : any
  }
}

const w = 4;
>w : 4
>4 : 4

var r = new Signal<Int<w>>();
>r : Signal<Int<4>>
>new Signal<Int<w>>() : Signal<Int<4>>
>Signal : typeof Signal

var s = r #* r;
>s : RtlExpr<Int<8>>
>r #* r : RtlExpr<Int<8>>
>r : Signal<Int<4>>
>r : Signal<Int<4>>

var x = new Signal<Int<8>>();
>x : Signal<Int<8>>
>new Signal<Int<8>>() : Signal<Int<8>>
>Signal : typeof Signal

var y = new Signal<Int<8>>();
>y : Signal<Int<8>>
>new Signal<Int<8>>() : Signal<Int<8>>
>Signal : typeof Signal

var z = x + y;
>z : RtlExpr<Int<8>>
>x + y : RtlExpr<Int<8>>
>x : Signal<Int<8>>
>y : Signal<Int<8>>

z += z;
>z += z : RtlExpr<Int<8>>
>z : RtlExpr<Int<8>>
>z : RtlExpr<Int<8>>

var b = z == 5;
>b : RtlExpr<boolean>
>z == 5 : RtlExpr<boolean>
>z : RtlExpr<Int<8>>
>5 : 5

var dr = new Driver<bit>();
>dr : Driver<bit>
>new Driver<bit>() : Driver<bit>
>Driver : typeof Driver

dr.is(1, when => x==5);
>dr.is(1, when => x==5) : void
>dr.is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>dr : Driver<bit>
>is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>1 : 1
>when => x==5 : (when: any) => RtlExpr<boolean>
>when : any
>x==5 : RtlExpr<boolean>
>x : Signal<Int<8>>
>5 : 5

dr.is(x == 1);
>dr.is(x == 1) : void
>dr.is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>dr : Driver<bit>
>is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>x == 1 : RtlExpr<boolean>
>x : Signal<Int<8>>
>1 : 1

function signal<T extends RtlScalar>(init?: T) {
>signal : <T extends RtlScalar>(init?: T) => Signal<T>
>init : T

  return new Signal<T>();
>new Signal<T>() : Signal<T>
>Signal : typeof Signal
}

function Heartbeat() {
>Heartbeat : () => void

  var counter = signal<uint32>(0);
>counter : Signal<uint32>
>signal<uint32>(0) : Signal<uint32>
>signal : <T extends RtlScalar>(init?: T) => Signal<T>
>0 : 0

  var valid = signal<bit>(0);
>valid : Signal<bit>
>signal<bit>(0) : Signal<bit>
>signal : <T extends RtlScalar>(init?: T) => Signal<T>
>0 : 0

  var accept = signal<bit>();
>accept : Signal<bit>
>signal<bit>() : Signal<bit>
>signal : <T extends RtlScalar>(init?: T) => Signal<T>

  var zero = signal<bit>();
>zero : Signal<bit>
>signal<bit>() : Signal<bit>
>signal : <T extends RtlScalar>(init?: T) => Signal<T>

  var d = new Driver<UInt<32>>();
>d : Driver<UInt<32>>
>new Driver<UInt<32>>() : Driver<UInt<32>>
>Driver : typeof Driver

  d.is(counter + 1);
>d.is(counter + 1) : void
>d.is : <U extends RtlScalar>(val: RtlExpr<UInt<32>>, cond?: (x: any) => RtlExpr<U>) => void
>d : Driver<UInt<32>>
>is : <U extends RtlScalar>(val: RtlExpr<UInt<32>>, cond?: (x: any) => RtlExpr<U>) => void
>counter + 1 : RtlExpr<uint32>
>counter : Signal<uint32>
>1 : 1

  var v = new Driver<bit>();
>v : Driver<bit>
>new Driver<bit>() : Driver<bit>
>Driver : typeof Driver

  v.is(1, when => counter == 1e6);
>v.is(1, when => counter == 1e6) : void
>v.is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>v : Driver<bit>
>is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>1 : 1
>when => counter == 1e6 : (when: any) => RtlExpr<boolean>
>when : any
>counter == 1e6 : RtlExpr<boolean>
>counter : Signal<uint32>
>1e6 : 1000000

  v.is(0, when => valid & accept);
>v.is(0, when => valid & accept) : void
>v.is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>v : Driver<bit>
>is : <U extends RtlScalar>(val: RtlExpr<bit>, cond?: (x: any) => RtlExpr<U>) => void
>0 : 0
>when => valid & accept : (when: any) => RtlExpr<UInt<1>>
>when : any
>valid & accept : RtlExpr<UInt<1>>
>valid : Signal<bit>
>accept : Signal<bit>
}

var i32 = new Signal<Int<32>>();
>i32 : Signal<Int<32>>
>new Signal<Int<32>>() : Signal<Int<32>>
>Signal : typeof Signal

i32 = 1;
>i32 = 1 : Signal<Int<32>>
>i32 : Signal<Int<32>>
>1 : 1

var xd = new Driver<Int<8>>();
>xd : Driver<Int<8>>
>new Driver<Int<8>>() : Driver<Int<8>>
>Driver : typeof Driver

xd.is(int8(i32 & 255));
>xd.is(int8(i32 & 255)) : void
>xd.is : <U extends RtlScalar>(val: RtlExpr<Int<8>>, cond?: (x: any) => RtlExpr<U>) => void
>xd : Driver<Int<8>>
>is : <U extends RtlScalar>(val: RtlExpr<Int<8>>, cond?: (x: any) => RtlExpr<U>) => void
>int8(i32 & 255) : Int<8>
>int8 : (x: number | Bits | RtlBits) => Int<8>
>i32 & 255 : RtlExpr<Int<32>>
>i32 : Signal<Int<32>>
>255 : 255


